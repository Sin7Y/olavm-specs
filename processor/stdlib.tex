\subsection{Stdlib}\label{subsec: : stdlib}
VM支持stdlib库的执行。比如无符号数的算术计算，常用hash函数(SHA256)等。
\subsubsection{u32 arithmatic}\label{subsec: u32-arithmatic}
OlaVM支持u32数据类型的算法计算。包括下边操作：
\begin{itemize}
    \item \verb|u32_add|
    \item \verb|u32_sub|
    \item \verb|u32_mul|
    \item \verb|u32_div|
\end{itemize}


\verb|u32 ADD|

u32的加法算法伪代码如下：

\begin{lstlisting}[language={}]
func u32_add(data_src_1: Felt, data_src_2: Felt) {
    MOV r_src1 data_src_1
    MOV r_src2 data_src_2

    range_check(r_src1, MAX_u32)
    range_check(r_src2, MAX_u32)

    ADD r_dst r_src1 r_src2
    %{
        (r_dst_hi, r_dst_lo) = split64(r_dst)
    %}


    range_check(r_dst_lo, MAX_u32)
    range_check(r_dst_hi, MAX_u32)

    MUL r_assert r_dst_hi 2^32
    ADD r_assert r_assert r_dst_low
    EQ r_dst r_assert

    return (r_dst_hi, r_dst_lo)
}
\end{lstlisting}


\verb|u32 SUB|

u32的减法算法伪代码如下：

\begin{lstlisting}[language={}]
func u32_sub(data_src_1: Felt, data_src_2: Felt) {
    MOV r_src1 data_src_1
    MOV r_src2 data_src_2

    range_check(r_src1, MAX_u32)
    range_check(r_src2, MAX_u32)

    local borrow_flag
    local difference
    %{
        if r_src1 > r_src2 {
            borrow_flag = 0
        } else {
            borrow_flag = 2^32
        }
        difference = borrow_flag + r_src1 - r_src2
    %}

    ADD r_assert1 r_src2 difference
    ADD r_assert2 r_src1 borrow_flag
    EQ r_assert1 r_assert2

    return (difference, borrow_flag)
}
\end{lstlisting}


\verb|u32 MUL|

u32的乘法算法伪代码如下：

\begin{lstlisting}[language={}]
func u32_mul(data_src_1: Felt, data_src_2: Felt) {
    MOV r_src1 data_src_1
    MOV r_src2 data_src_2

    range_check(r_src1, MAX_u32)
    range_check(r_src2, MAX_u32)

    MUL r_dst r_src1 r_src2
    %{
        (r_dst_hi, r_dst_lo) = split64(r_dst)
    %}

    range_check(r_dst_lo, MAX_u32)
    range_check(r_dst_hi, MAX_u32)

    MUL r_assert r_dst_hi 2^32
    ADD r_assert r_assert r_dst_low
    EQ r_dst r_assert

    return (r_dst_hi, r_dst_lo)
}
\end{lstlisting}


\verb|u32 DIV|

u32的除法算法伪代码如下：

\begin{lstlisting}[language={}]
func u32_div(data_src_1: Felt, data_src_2: Felt) {
    MOV r_src1 data_src_1
    MOV r_src2 data_src_2

    range_check(r_src1, MAX_u32)
    range_check(r_src2, MAX_u32)

    local quotient
    local remainder
    %{
        quotient = r_src1 / r_src2
        remainder = r_src1 % r_src2
    %}

    MUL r_assert r_src2 quotient
    ADD r_assert r_assert remainder
    EQ r_src1 r_assert

    return (r_dst_hi, r_dst_lo)
}
\end{lstlisting}

\subsubsection{u64 arithmatic}\label{subsec: u64-arithmatic}

OlaVM支持u64数据类型的算法计算。包括下边操作：
\begin{itemize}
    \item \verb|u64_add|
    \item \verb|u64_sub|
    \item \verb|u64_mul|
    \item \verb|u64_div|
\end{itemize}

\verb|u64 ADD|

u64的加法算法伪代码如下：

\begin{lstlisting}[language={}]
func u64_add(data_src_1_lo: Felt, data_src_1_hi: Felt, data_src_2_lo: Felt, data_src_2_hi: Felt) {
    range_check(r0, MAX_u32)
    range_check(r1, MAX_u32)

    ADD r4 r0 r1
    %{
        (mem[addr_hi0], mem[addr_lo0]) = split64(r4)
    %}

    mload r5, mem[addr_lo0]
    mload r6, mem[addr_hi0]

    range_check(r5, MAX_u32)
    range_check(r6, MAX_u32)


    MUL r7 r6 2^32
    ADD r7 r7 r0
    ASSERT r4 r7

    range_check(r2, MAX_u32)
    range_check(r3, MAX_u32)

    ADD r4 r2 r3
    ADD r4 r4 r6

    %{
        (mem[addr_hi1], mem[addr_lo1]) = split64(r4)
    %}

    mload r0, mem[addr_lo1]
    mload r1, mem[addr_hi1]

    range_check(r0, MAX_u32)
    range_check(r1, MAX_u32)

    MUL r1 r1 2^32
    ADD r1 r1 r0
    ASSERT r4 r1

    return (mem[addr_lo0], mem[addr_lo1], mem[addr_hi1])
}
\end{lstlisting}

\verb|u64 MUL|

u64的乘法算法伪代码如下：

\begin{lstlisting}[language={}]
func u64_mul(data_src_1_lo: Felt, data_src_1_hi: Felt, data_src_2_lo: Felt, data_src_2_hi: Felt) {
    mload r0 [fp-3]
    mload r1 [fp-5]

    range_check(r0, MAX_u32)
    range_check(r1, MAX_u32)

    MUL r2 r0 r1
    %{
        (mem[addr_hi0], mem[addr_lo0]) = split64(r2)
    %}

    mload r0, mem[addr_lo0]
    mload r1, mem[addr_hi0]

    range_check(r0, MAX_u32)
    range_check(r1, MAX_u32)


    MUL r3 r1 2^32
    ADD r3 r3 r0
    ASSERT r2 r3

    mload r4 [fp-4]
    mload r5 [fp-6]

    range_check(r4, MAX_u32)
    range_check(r5, MAX_u32)

    MUL r2 r4 r5
    ADD r2 r2 r1

    %{
        (mem[addr_hi1], mem[addr_lo1]) = split64(r2)
    %}

    mload r6, mem[addr_lo1]
    mload r7, mem[addr_hi1]

    range_check(r6, MAX_u32)
    range_check(r7, MAX_u32)

    MUL r7 r7 2^32
    ADD r7 r7 r6
    ASSERT r2 r7

    return (mem[addr_lo0], mem[addr_lo1], mem[addr_hi1])
}
\end{lstlisting}

